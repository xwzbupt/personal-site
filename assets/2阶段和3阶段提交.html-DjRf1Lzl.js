import{_ as t,c as e,a as r,o as i}from"./app-mRFOk-Ym.js";const a={};function p(c,o){return i(),e("div",null,[...o[0]||(o[0]=[r('<h1 id="_2阶段和3阶段提交" tabindex="-1"><a class="header-anchor" href="#_2阶段和3阶段提交"><span>2阶段和3阶段提交</span></a></h1><blockquote><p>来自于Alluxio副总裁范斌的文章</p><p>作者：范斌</p></blockquote><p>2PC (两阶段提交)协议和3PC (三阶段提交)协议本身其实很简单. 我尽量通过少写字, 多上图的方法, 用一个coordinator和三个voter达成共识的例子来说明这两个协议的想法.</p><h2 id="_2pc-两阶段提交-协议" tabindex="-1"><a class="header-anchor" href="#_2pc-两阶段提交-协议"><span>2PC (两阶段提交)协议</span></a></h2><p><strong>2PC的原理</strong></p><p>顾名思义, 2PC协议有两个阶段:Propose和Commit. <strong>在无failure情况下</strong>的2PC协议流程的画风是这样的:</p><ul><li><p>Propose阶段:</p></li><li><ul><li>coordinator: &quot;昨夜验人有惊喜, 今天都投票出六娃&quot;</li><li>voter1/voter2/voter3: &quot;好的女王大人!&quot;</li></ul></li><li><p>Commit阶段</p></li><li><ul><li>coordinator: &quot;投六娃&quot;</li><li>voter1/voter2/voter3: &quot;投了女王大人!&quot; (画外音: 六娃扑街)</li></ul></li></ul><p><img src="https://pic3.zhimg.com/v2-e2f7149a81d9ad3aa46589e25503d688_720w.jpg?source=d16d100b" alt="img" loading="lazy"><img src="https://pic3.zhimg.com/80/v2-e2f7149a81d9ad3aa46589e25503d688_1440w.jpg?source=d16d100b" alt="img" loading="lazy">图1: 2PC, coordinator提议通过, voter{1,2,3}达成新的共识</p><p>如果有至少一个voter (比如voter3)在Propose阶段投了反对票, 那么propose通过失败. coordinator就会在Commit(or abort)阶段跟所有voter说, 放弃这个propose.</p><p><img src="https://pic1.zhimg.com/v2-d40abfa365ed84e84e264ba13900f64b_720w.jpg?source=d16d100b" alt="img" loading="lazy"><img src="https://pic1.zhimg.com/80/v2-d40abfa365ed84e84e264ba13900f64b_1440w.jpg?source=d16d100b" alt="img" loading="lazy">图2: 2PC, coordinator提议没有通过, voter{1,2,3}保持旧有的共识</p><p><strong>2PC的缺陷</strong></p><p>2PC的缺点在于不能处理fail-stop形式的节点failure. 比如下图这种情况. 假设coordinator和voter3都在Commit这个阶段crash了, 而voter1和voter2没有收到commit消息. 这时候voter1和voter2就陷入了一个困境. 因为他们并不能判断现在是两个场景中的哪一种: (1)上轮全票通过然后voter3第一个收到了commit的消息并在commit操作之后crash了, (2)上轮voter3反对所以干脆没有通过.</p><p><img src="https://pic2.zhimg.com/v2-a9e4ef8b9082ffdf76bc426e61ba3ed2_720w.jpg?source=d16d100b" alt="img" loading="lazy"><img src="https://pic2.zhimg.com/80/v2-a9e4ef8b9082ffdf76bc426e61ba3ed2_1440w.jpg?source=d16d100b" alt="img" loading="lazy">图3: 2PC, coordinator和voter3 crash, voter{1,2}无法判断当前状态而卡死</p><p>2PC在这种fail-stop情况下会失败是因为voter在得知Propose Phase结果后就直接commit了, 而并没有在commit之前告知其他voter自己已收到Propose Phase的结果. 从而导致在coordinator和一个voter双双掉线的情况下, 其余voter不但无法复原Propose Phase的结果, 也无法知道掉线的voter是否打算甚至已经commit. 为了解决这一问题, 3PC了解一下.</p><hr><h2 id="_3pc-三阶段提交-协议" tabindex="-1"><a class="header-anchor" href="#_3pc-三阶段提交-协议"><span>3PC (三阶段提交)协议</span></a></h2><p><strong>3PC的原理</strong></p><p>简单的说来, 3PC就是把2PC的Commit阶段拆成了PreCommit和Commit两个阶段. 通过进入增加的这一个PreCommit阶段, voter可以得到Propose阶段的投票结果, 但不会commit; 而通过进入Commit阶段, voter可以盘出其他每个voter也都打算commit了, 从而可以放心的commit.</p><p><strong>换言之, 3PC在2PC的Commit阶段里增加了一个barrier</strong>(即相当于告诉其他所有voter, 我收到了Propose的结果啦). 在这个barrier之前coordinator掉线的话, 其他voter可以得出结论不是每个voter都收到Propose Phase的结果, 从而放弃或选出新的coordinator; 在这个barrier之后coordinator掉线的话, 每个voter会放心的commit, 因为他们知道其他voter也都做同样的计划.</p><p><img src="https://pic3.zhimg.com/v2-28c17c86e689007015a4853f0d0c4a89_720w.jpg?source=d16d100b" alt="img" loading="lazy"><img src="https://pic3.zhimg.com/80/v2-28c17c86e689007015a4853f0d0c4a89_1440w.jpg?source=d16d100b" alt="img" loading="lazy">图4: 3PC, coordinator提议通过, voter{1,2,3}达成新的共识</p><p><strong>3PC的缺陷</strong></p><p>3PC可以有效的处理fail-stop的模式, 但不能处理网络划分(network partition)的情况---节点互相不能通信. 假设在PreCommit阶段所有节点被一分为二, 收到preCommit消息的voter在一边, 而没有收到这个消息的在另外一边. 在这种情况下, 两边就可能会选出新的coordinator而做出不同的决定.</p><p><img src="https://pica.zhimg.com/v2-7a18adc27a2bd7b5f5926dd999bc7bb3_720w.jpg?source=d16d100b" alt="img" loading="lazy"><img src="https://pica.zhimg.com/80/v2-7a18adc27a2bd7b5f5926dd999bc7bb3_1440w.jpg?source=d16d100b" alt="img" loading="lazy">图5: 3PC, network partition, voter{1,2,3}失去共识</p><p>除了网络划分以外, 3PC也不能处理fail-recover的错误情况. 简单说来当coordinator收到preCommit的确认前crash, 于是其他某一个voter接替了原coordinator的任务而开始组织所有voter commit. 而与此同时原coordinator重启后又回到了网络中, 开始继续之前的回合---发送abort给各位voter因为它并没有收到preCommit. 此时有可能会出现原coordinator和继任的coordinator给不同节点发送相矛盾的commit和abort指令, 从而出现个节点的状态分歧.</p><p>这种情况等价于一个更真实或者更负责的网络环境假设: 异步网络. 在这种假设下, 网络传输时间可能任意长. 为了解决这种情况, 那就得请出下一篇的主角: Paxos</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ol><li>2PC使用两个roundtrip来达成新的共识或维持旧有的共识. 其局限性在于不能保证有节点永久性崩溃(fail-stop)的情况下算法能向前推进;</li><li>3PC扩展了2PC, 使用三个roundtrip达成共识. 其局限性在于不能保证在节点暂时性崩溃(fail-recover), 或是有网络划分的情况下, 共识依旧成立.</li></ol>',27)])])}const m=t(a,[["render",p]]),s=JSON.parse('{"path":"/basics/distribute/2%E9%98%B6%E6%AE%B5%E5%92%8C3%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.html","title":"2阶段和3阶段提交","lang":"zh-CN","frontmatter":{"description":"2阶段和3阶段提交 来自于Alluxio副总裁范斌的文章 作者：范斌 2PC (两阶段提交)协议和3PC (三阶段提交)协议本身其实很简单. 我尽量通过少写字, 多上图的方法, 用一个coordinator和三个voter达成共识的例子来说明这两个协议的想法. 2PC (两阶段提交)协议 2PC的原理 顾名思义, 2PC协议有两个阶段:Propose和...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2阶段和3阶段提交\\",\\"image\\":[\\"https://pic3.zhimg.com/v2-e2f7149a81d9ad3aa46589e25503d688_720w.jpg?source=d16d100b\\",\\"https://pic3.zhimg.com/80/v2-e2f7149a81d9ad3aa46589e25503d688_1440w.jpg?source=d16d100b\\",\\"https://pic1.zhimg.com/v2-d40abfa365ed84e84e264ba13900f64b_720w.jpg?source=d16d100b\\",\\"https://pic1.zhimg.com/80/v2-d40abfa365ed84e84e264ba13900f64b_1440w.jpg?source=d16d100b\\",\\"https://pic2.zhimg.com/v2-a9e4ef8b9082ffdf76bc426e61ba3ed2_720w.jpg?source=d16d100b\\",\\"https://pic2.zhimg.com/80/v2-a9e4ef8b9082ffdf76bc426e61ba3ed2_1440w.jpg?source=d16d100b\\",\\"https://pic3.zhimg.com/v2-28c17c86e689007015a4853f0d0c4a89_720w.jpg?source=d16d100b\\",\\"https://pic3.zhimg.com/80/v2-28c17c86e689007015a4853f0d0c4a89_1440w.jpg?source=d16d100b\\",\\"https://pica.zhimg.com/v2-7a18adc27a2bd7b5f5926dd999bc7bb3_720w.jpg?source=d16d100b\\",\\"https://pica.zhimg.com/80/v2-7a18adc27a2bd7b5f5926dd999bc7bb3_1440w.jpg?source=d16d100b\\"],\\"dateModified\\":\\"2025-06-21T15:03:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Weiser\\",\\"url\\":\\"https://github.com/xwzbupt\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-v2-demo.mrhope.site/basics/distribute/2%E9%98%B6%E6%AE%B5%E5%92%8C3%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.html"}],["meta",{"property":"og:site_name","content":"Weiser"}],["meta",{"property":"og:title","content":"2阶段和3阶段提交"}],["meta",{"property":"og:description","content":"2阶段和3阶段提交 来自于Alluxio副总裁范斌的文章 作者：范斌 2PC (两阶段提交)协议和3PC (三阶段提交)协议本身其实很简单. 我尽量通过少写字, 多上图的方法, 用一个coordinator和三个voter达成共识的例子来说明这两个协议的想法. 2PC (两阶段提交)协议 2PC的原理 顾名思义, 2PC协议有两个阶段:Propose和..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pic3.zhimg.com/v2-e2f7149a81d9ad3aa46589e25503d688_720w.jpg?source=d16d100b"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T15:03:37.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T15:03:37.000Z"}]]},"git":{"createdTime":1750518217000,"updatedTime":1750518217000,"contributors":[{"name":"weiser","username":"weiser","email":"1134685563@qq.com","commits":1,"url":"https://github.com/weiser"}]},"readingTime":{"minutes":4.28,"words":1284},"filePathRelative":"basics/distribute/2阶段和3阶段提交.md","excerpt":"\\n<blockquote>\\n<p>来自于Alluxio副总裁范斌的文章</p>\\n<p>作者：范斌</p>\\n</blockquote>\\n<p>2PC (两阶段提交)协议和3PC (三阶段提交)协议本身其实很简单. 我尽量通过少写字, 多上图的方法, 用一个coordinator和三个voter达成共识的例子来说明这两个协议的想法.</p>\\n<h2>2PC (两阶段提交)协议</h2>\\n<p><strong>2PC的原理</strong></p>\\n<p>顾名思义, 2PC协议有两个阶段:Propose和Commit.  <strong>在无failure情况下</strong>的2PC协议流程的画风是这样的:</p>","autoDesc":true}');export{m as comp,s as data};
